# Week 03：并发与 context

## 本周目标

理解 goroutine、channel、mutex、context，并在列表接口中加入超时控制；完成一个可运行的聊天室并发示例。

## 详细步骤

1. 用最小示例分别练习 goroutine/channel/select。
2. 对比两种并发同步方式：mutex 与 channel。
3. 为列表接口加 `context.WithTimeout`（如 200ms/500ms，按你的实现定）。
4. 模拟慢请求并验证超时返回行为。
5. 在日志中记录超时触发点（便于后续排查）。
6. 总结“什么时候用 mutex，什么时候用 channel”。
7. 设计并实现聊天室最小模型（房间事件循环 + 用户收发消息）。
8. 为聊天室补齐核心能力：加入、离开、广播、房间关闭、慢消费者处理。
9. 使用 `context` 控制用户会话生命周期（取消时自动离开，避免 goroutine 泄漏）。
10. 为聊天室补测试：广播成功、重复用户名、context 取消、关闭房间。

## 建议实践清单

- 避免 goroutine 泄漏，确保协程有退出路径。
- 在超时场景返回明确错误码和信息。
- 对共享状态读写必须有同步机制。
- 聊天室广播建议采用“单事件循环 + channel”模型，集中管理共享状态。
- 对慢消费者设置策略（丢弃、踢出、背压），并记录日志。

## 验收清单

- [ ] 列表接口具备 deadline 控制。
- [ ] 能清楚解释 mutex 和 channel 的使用边界。
- [ ] 超时场景有测试或可复现实验。
- [ ] 聊天室支持加入/离开/广播，且可稳定运行。
- [ ] 聊天室关键并发场景有测试（重复加入、取消退出、关闭房间）。

## 产出物

- 超时控制实现代码。
- 并发模型总结笔记。
- 聊天室并发示例代码与测试。

## 常见风险与排查

- 忘记 `cancel()`：始终在创建 timeout 后 `defer cancel()`。
- 无缓冲 channel 阻塞：确认发送和接收是否成对。
- 广播时直接遍历阻塞发送：慢用户会拖垮全房间，需使用缓冲 channel 或降级策略。
- 房间关闭后继续发送：需要统一关闭状态，避免 panic（send on closed channel）。
